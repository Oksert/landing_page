<html><head></head><body><h2 id="c2a0d092d0b2d0b5d0b4d0b5d0bdd0b8d0b53c7370616e2069643d22676f6f675f32313038313631313830223e3c2f7370616e3e3c7370616e2069643d22676f6f675f32313038313631313831223e3c2f7370616e3e"> Введение<span id="goog_2108161180"></span><span id="goog_2108161181"></span></h2><div>Организация данных в структуры - одна из самых частых задач в Java, поэтому было бы странно, если бы в Java не было встроенных средств для работы с различными группами данных.</div><h2 id="d09cd0b0d181d181d0b8d0b2d18b">Массивы</h2><div>Непосредственно язык Java поддерживает только один возможный способ организации данных - это массивы.</div><div>Так мы их создаем:</div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#7f0055;font-weight:bold;">int</span>[] primes = <span style="color:#7f0055;font-weight:bold;">new</span> <span style="color:#7f0055;font-weight:bold;">int</span>[k];</pre></div><div>Или так:</div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#7f0055;font-weight:bold;">int</span>[] primes = {1,3};</pre></div><div>У массивов есть длина</div><div><pre style="line-height:normal;font-size:medium;">primes.length</pre></div><div>И она <strong>постоянна.</strong>
</div><div>Длину массива нельзя увеличить.</div><div><em><strong>Достоинства массивов</strong></em></div><div><ul><li>скорость</li><li>помнят тип элемента, поскольку не используют параметризацию</li></ul><div><strong><em>Недостатки </em></strong><em><strong>массивов</strong></em>
</div></div><div><ul><li>низкая функциональность, нет даже функции поиска элементы в массиве</li><li>постоянный размер, невозможно просто так добавить элементы в массив</li></ul><h3 id="3c62723ed098d181d0bfd0bed0bbd18cd0b7d0bed0b2d0b0d0bdd0b8d0b520d0bcd0b0d181d181d0b8d0b2d0bed0b2"><br>Использование массивов</h3></div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#3f7f59;">//Инициализация</span>
int[] vec = new int[3];
vec[0] = 1;
vec[1] = 2;
vec[2] = 3;
<span style="color:#3f7f59;">//Инициализация по-короче</span>
int[] vec2 = {1,2,3};
<span style="color:#3f7f59;">//Обход элементов</span>
for(int i = 0; i < vec.length; i++)
	sum += vec[i];
<span style="color:#3f7f59;">//Обход элементов по-короче</span>
for(int elem: vec2)
	sum2 += elem;</pre></div><div><br></div><div><h2 id="d09ad0bbd0b0d181d181d18b20d0bad0bed0bbd0bbd0b5d0bad186d0b8d0b9">Классы коллекций</h2><div> - это реализованные в стандартной библиотеке (java.util) параметризованные классы и интерфейсы. Также называются Java Collection Framework.</div><div> </div></div><div><div><strong><em>Достоинства классов коллекций </em></strong></div><div><ul><li>высокая функциональность: наличие классов реализующих динамические массивы, множества уникальных элементов, словарей значений</li><li>собственный менеджер памяти, следящий за размером коллекции</li></ul></div><div><em><strong>Недостатки классов коллекций </strong></em></div><div><ul><li>реализованы используя параметризацию (во время выполнения не помнят тип элемента)</li><li>не могут использоваться с примитивными типами, используют обертки над примитивными типами</li><li>в среднем медленнее массивов, особенно для примитивных типов</li></ul></div><div><br></div><h3 id="d098d0b5d180d0b0d180d185d0b8d18f20d0b8d0bdd182d0b5d180d184d0b5d0b9d181d0bed0b220d0bad0bed0bbd0bbd0b5d0bad186d0b8d0b920d0b2206a617661">Иерархия интерфейсов коллекций в Java</h3><div>В Java наиболле часто используются три типа интерфейсов:</div><div><strong><em>List </em></strong>- нумерованный список элементов</div><div><em><strong>Set </strong></em>- множество уникальных элементов</div><div><em><strong>Map </strong></em>- множество пар элементов, в котором первый элемент пары уникален, также называется словарем</div><div><span id="goog_140102892"></span><span id="goog_140102893"></span><br></div><div><span id="goog_1536856870"></span><span id="goog_1536856871"></span><span id="goog_1435706579"></span><span id="goog_1435706580"></span><br></div><h3 id="list">List</h3><div>Этот интерфейс поддерживает основные операции по работе с динамическими массивами</div><div>Две его основные реализации - <a class="wiki_link" href="/wiki/show/vsm2_1step/ArrayList" title="ArrayList">ArrayList</a> и <a class="wiki_link" href="/wiki/show/vsm2_1step/LinkedList" title="LinkedList">LinkedList</a>. </div><div>Они оба реализуют интерфейс List, но <a class="wiki_link" href="/wiki/show/vsm2_1step/ArrayList" title="ArrayList">ArrayList</a> реализован через автоматически расширяющийся массив, а <a class="wiki_link" href="/wiki/show/vsm2_1step/LinkedList" title="LinkedList">LinkedList</a> - как связанный список.</div><div><br></div><p><a class="wiki_link" href="/wiki/show/vsm2_1step/ArrayList" title="ArrayList">ArrayList</a></p><div>+Быстрое обращение по индексу</div><div>-Быстрая вставка в любое место массива</div><div>-не может автоматически уменьшить размер внутреннего массива (требуется вызов resize)</div><div><a class="wiki_link" href="/wiki/show/vsm2_1step/LinkedList" title="LinkedList">LinkedList</a></div><div>+Быстрая вставка в любое место массива</div><div>+автоматически уменьшается размер</div><div>-Медленное обращение по индексу</div><div><br></div></div><div><h3 id="d09ad0bbd0b0d181d181d18b20767320d0b8d0bdd182d0b5d180d184d0b5d0b9d181d18b">Классы VS интерфейсы</h3><div>И List и Set и Map являются интерфейсами, для каждого из которых предусмотрено несколько готовых реализаций, каждая из которых обычно оптимизирована для различных реализаций.</div><div>И если мы узнаем, что у нас часто происходит вставка внутрь массива, а мы используем <a class="wiki_link" href="/wiki/show/vsm2_1step/ArrayList" title="ArrayList">ArrayList</a>, то мы всегда можем заменить его на <a class="wiki_link" href="/wiki/show/vsm2_1step/LinkedList" title="LinkedList">LinkedList</a>.</div><div><div>Поэтому всегда пишите </div></div><div><pre style="line-height:normal;font-size:medium;">List<MyObject> <span style="color:#7f0055;font-weight:bold;">list</span> = <span style="color:#7f0055;font-weight:bold;">new</span> ArrayList<MyObject>();<br></pre></div><div>а не </div><div><pre style="line-height:normal;font-size:medium;">ArrayList<MyObject> <span style="color:#7f0055;font-weight:bold;">list</span> = <span style="color:#7f0055;font-weight:bold;">new</span> ArrayList<MyObject>();</pre></div><h3 id="3c62723ed098d181d0bfd0bed0bbd18cd0b7d0bed0b2d0b0d0bdd0b8d0b520d181d0bfd0b8d181d0bad0bed0b2"><br>Использование списков</h3></div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#3f7f59;">//Инициализация</span>
List<Integer> <span style="color:#7f0055;font-weight:bold;">list</span> = <span style="color:#7f0055;font-weight:bold;">new</span> ArrayList<Integer>();
<span style="color:#7f0055;font-weight:bold;">list</span>.add(1);
<span style="color:#7f0055;font-weight:bold;">list</span>.add(2);
<span style="color:#7f0055;font-weight:bold;">list</span>.add(3);
<span style="color:#3f7f59;">//Инициализация по-короче</span>
List<Integer> list2 = Arrays.asList(1,2,3);
<span style="color:#3f7f59;">//Обход элементов</span>
<span style="color:#7f0055;font-weight:bold;">for</span>(<span style="color:#7f0055;font-weight:bold;">int</span> i = 0; i < <span style="color:#7f0055;font-weight:bold;">list</span>.size(); i++)
	sum += <span style="color:#7f0055;font-weight:bold;">list</span>.get(i);
<span style="color:#3f7f59;">//Обход элементов по-короче</span>
<span style="color:#7f0055;font-weight:bold;">for</span>(Integer elem: list2)
	sum2 += elem;</pre></div><div><br></div><div><h3 id="73657420d0b82068617368736574">Set и <a class="wiki_link" href="/wiki/show/vsm2_1step/HashSet" title="HashSet">HashSet</a>
</h3><div>Представляет собой множество уникальных значений, основные операции - добавление и проверка на вхождение. Наиболее часто используемая реализация - <a class="wiki_link" href="/wiki/show/vsm2_1step/HashSet" title="HashSet">HashSet</a>
</div></div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#3f7f59;">//Инициализация</span>
Set<Integer> <span style="color:#7f0055;font-weight:bold;">set</span> = <span style="color:#7f0055;font-weight:bold;">new</span> HashSet<Integer>();
<span style="color:#7f0055;font-weight:bold;">set</span>.add(1);
<span style="color:#7f0055;font-weight:bold;">set</span>.add(2);
<span style="color:#7f0055;font-weight:bold;">set</span>.add(3);
....
<span style="color:#3f7f59;">// проверка на вхождение элементов</span>
<span style="color:#7f0055;font-weight:bold;">if</span> (<span style="color:#7f0055;font-weight:bold;">set</span>.contains(Integer(1)))
	......
<span style="color:#3f7f59;">//Обход элементов</span>
<span style="color:#7f0055;font-weight:bold;">for</span>(Integer elem: <span style="color:#7f0055;font-weight:bold;">set</span>)
	sum += elem;</pre></div><div><br></div><div><div><h3 id="3c7370616e207374796c653d22666f6e742d66616d696c793a20696e68657269743b223e6d6170c2a03c2f7370616e3ed0b820686173686d6170" style=""><span style="font-family:inherit;">Map </span>и <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a>
</h3></div><div>Множество пар элементов, в котором первый элемент пары уникален, также называется словарем. Наиболее часто используемая реализация - <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a>.</div></div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#3f7f59;">//Инициализация</span>
Map<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer> <span style="color:#7f0055;font-weight:bold;">map</span> = <span style="color:#7f0055;font-weight:bold;">new</span> HashMap<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer>();
<span style="color:#7f0055;font-weight:bold;">map</span>.put(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">one</span><span style="color:#2a00ff;">"</span>, 1);
<span style="color:#7f0055;font-weight:bold;">map</span>.put(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">two</span><span style="color:#2a00ff;">"</span>, 2);
<span style="color:#7f0055;font-weight:bold;">map</span>.put(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">three</span><span style="color:#2a00ff;">"</span>, 3);
....
<span style="color:#3f7f59;">// проверка на вхождение элементов</span>
<span style="color:#7f0055;font-weight:bold;">if</span> (<span style="color:#7f0055;font-weight:bold;">map</span>.contains(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">one</span><span style="color:#2a00ff;">"</span>))
	......
	
<span style="color:#3f7f59;">//извлечение по ключу</span>
<span style="color:#7f0055;font-weight:bold;">int</span> a = <span style="color:#7f0055;font-weight:bold;">map</span>.get(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">three</span><span style="color:#2a00ff;">"</span>);

<span style="color:#3f7f59;">//ключи уникальны:</span>
<span style="color:#7f0055;font-weight:bold;">map</span>.put(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">one</span><span style="color:#2a00ff;">"</span>, 1);
<span style="color:#7f0055;font-weight:bold;">map</span>.put(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">one</span><span style="color:#2a00ff;">"</span>, 2);
<span style="color:#7f0055;font-weight:bold;">int</span> b = <span style="color:#7f0055;font-weight:bold;">map</span>.get(<span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">one</span><span style="color:#2a00ff;">"</span>); <span style="color:#3f7f59;">// b = 2</span></pre></div><div>В отличии от интерфейсов Set и List, интерфейс Map не реализует итерацию. Это связано с тем, что не ясно, что можно подразумевать под итерацией в данном случае: итерацию по уникальным ключам или по парам значений. </div><div><br></div><div><div><br></div><div>Итерация по ключам заключается в итерации по Set'у ключей:</div><div><pre style="line-height:normal;font-size:medium;">Map<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer> <span style="color:#7f0055;font-weight:bold;">map</span> = <span style="color:#7f0055;font-weight:bold;">new</span> HashMap<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer>();
....
<span style="color:#7f0055;font-weight:bold;">for</span> (<span style="color:#7f0055;font-weight:bold;">String</span> key: <span style="color:#7f0055;font-weight:bold;">map</span>.keysSet())
	...</pre></div><div><span class="Apple-tab-span" style="white-space:pre;"></span></div><div>Если же нам требуется выполнить итерацию по парам, то сразу напрашивается решение:</div><div><pre style="line-height:normal;font-size:medium;">Map<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer> <span style="color:#7f0055;font-weight:bold;">map</span> = <span style="color:#7f0055;font-weight:bold;">new</span> HashMap<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer>();
....
<span style="color:#7f0055;font-weight:bold;">for</span> (<span style="color:#7f0055;font-weight:bold;">String</span> key: <span style="color:#7f0055;font-weight:bold;">map</span>.keysSet())
	<span style="color:#7f0055;font-weight:bold;">int</span> value = <span style="color:#7f0055;font-weight:bold;">map</span>.get(key);
	...</pre></div></div><div>Однако так лучше не писать, на каждой итерации будет происходить поиск объекта по ключу.</div><div>Гораздо лучше сразу получить все пары:</div><div><pre style="line-height:normal;font-size:medium;">Map<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer> <span style="color:#7f0055;font-weight:bold;">map</span> = <span style="color:#7f0055;font-weight:bold;">new</span> HashMap<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer>();
....
<span style="color:#7f0055;font-weight:bold;">for</span> (Map.Entry<<span style="color:#7f0055;font-weight:bold;">String</span>,Integer> <span style="color:#7f0055;font-weight:bold;">pair</span>: <span style="color:#7f0055;font-weight:bold;">map</span>.entrySet())
	<span style="color:#7f0055;font-weight:bold;">String</span> key = <span style="color:#7f0055;font-weight:bold;">pair</span>.getKey();
	<span style="color:#7f0055;font-weight:bold;">int</span> value = <span style="color:#7f0055;font-weight:bold;">pair</span>.getValue();
	...</pre></div><h3 id="d0a3d181d182d180d0bed0b9d181d182d0b2d0be206d617020d0b820d0b8d181d0bfd0bed0bbd18cd0b7d0bed0b2d0b0d0bdd0b8d0b520d185d18dd188d0b5d0b9">Устройство Map и использование хэшей</h3><div><div>Рассмотрим как происходит поиск элемента в <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a> и почему он значительно быстрее чем просто поиск в массиве ключей</div><div>Если кратко - то реализация основана на попытке занумеровать множество ключей Map. Для этого делается следующее:</div><div><ul><li>все классы Java реализуют метод hashCode() - возвращающий соответствующее объекту значение типа int</li><li>реализация <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a> содержит массив специальных "корзин". </li></ul></div><div><ol><li>Перед помещением пары в map вычисляется номер ее корзины как остаток от деления hashCode() ключа и числа корзин.</li><li>Когда понадобится поиск элемента по ключу, он будет вестись только внутри необходимой корзины. Внутри корзины ключи сравниваются уже по значению, используя функцию equals.</li><li>При этом в корзине обычно не более 1-2 элементов, представляющих собой пары ключ-значение.</li></ol></div><div><a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a> сам смотрит сколько должно быть в нем корзин, их число растет с ростом числа элементов.</div><div>При создании <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a> ему можно передать начальное число корзин, а также плотность заполенения (максимальное соотношения числа элементов к числу корзин).</div><div>По-умолчанию вначале 16 корзин, а плотность заполнения - 0,75 (первое расширение произойдет после добавления 12-го элемента).</div></div><div><div><a class="wiki_link" href="/wiki/show/vsm2_1step/HashSet" title="HashSet">HashSet</a> реализован аналогично.</div></div><div><br></div><div><h3 id="657175616c7320d0b8c2a068617368636f6465">equals и hashCode</h3><div>Из описанного следуют важные условия, накладываемые на класс ключей (встроенные классы им удовлетворяют)</div></div><div><ul><li>необходимость реализации метода equals. По умолчанию этот метод возвращает true, только если ссылки на объекты совпадают.</li><li>раз мы переопределили метод equals, мы должны переопределить метод hashCode(), при этом такой метод должен удовлетворять следующим требованиям:</li><ul><li>если a.equals(b), то a.hashCode() == b.hashCode()</li><li>если объект не менялся, то его hashCode() тоже не должен меняться</li><li>у разных объектов hashCode() могут совпадать</li></ul></ul><h4 id="3c62723ed0a0d0b5d0bad0bed0bcd0b5d0bdd0b4d0b0d186d0b8d0b820d0bfd0be20d0bfd0b5d180d0b5d0bed0bfd180d0b5d0b4d0b5d0bbd0b5d0bdd0b8d18e20657175616c73286f626a656374206f29"><br>Рекомендации по переопределению equals(Object o)</h4></div><div><div><ul><li>объекты разных классов совпадают только, если оба равны null</li><li>объекты одного класса совпадают только, если совпадают их поля: a.field.equals(b.field) для всех полей field класса объектов a и b </li><li>служебные поля (например, кэш) возможно не должны сравниваться</li></ul></div></div><h4 id="3c62723ed0a0d0b5d0bad0bed0bcd0b5d0bdd0b4d0b0d186d0b8d0b820d0bfd0be20d0bfd0b5d180d0b5d0bed0bfd180d0b5d0b4d0b5d0bbd0b5d0bdd0b8d18e2068617368636f64652829"><br>Рекомендации по переопределению hashCode()</h4><div><div>Обязательным требованиям на ф-цию hashCode удовлетворить просто:</div></div><div><pre style="line-height:normal;font-size:medium;"><span style="color:#7f0055;font-weight:bold;">public</span> <span style="color:#7f0055;font-weight:bold;">int</span> hashCode(){ 
	<span style="color:#7f0055;font-weight:bold;">return</span> 42; <span style="color:#3f7f59;">// худшая в мире реализация hashCode(), которая будет совершенно правильно работать</span>
}</pre></div><div><div><br></div><div>Не трудно понять, что с такой функцией все наши <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a> превратятся просто в связанные списки - все элементы будут в одной корзине.</div><div>Реализовывая hashCode() нужно стараться, чтобы ее значения лежали равномерно на всем множестве значений int.</div><div>Рекомендуемая реализация: </div><div><ul><li><span class="Apple-tab-span" style="white-space:pre;"> </span>Находим hashCode() первого поля класса и умножаем его на небольшое простое число, например 11</li><li><span class="Apple-tab-span" style="white-space:pre;"> </span>Находим hashCode() следующего поля класса и умножаем его на другое небольшое простое число, например 31, прибавляем результат к сумме</li><li><span class="Apple-tab-span" style="white-space:pre;"> </span>У массивов hashCode() считается как сумма попарных произведений элементов на простый числа</li><li><span class="Apple-tab-span" style="white-space:pre;"> </span>Если объект имеет уникальное поле (например Id в базе, берем его)</li><li><span class="Apple-tab-span" style="white-space:pre;"> </span>Если объект не изменяемый запоминаем его hashCode() при первом вызове (строки в Java именно так и делают)</li><li><span class="Apple-tab-span" style="white-space:pre;"> </span>Если полей слишком много - берем наиболее часто меняющиеся (касается в первую очередь массивов)</li></ul></div><div>Простые числа берутся, чтобы равномерно распределялись остатки от деления на число корзин в <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a>
</div><div><br></div><h2 id="d09dd0b0d0bfd0bed181d0bbd0b5d0b4d0bed0ba2e">Напоследок.</h2><div><h4 id="3c6f6c633e3c6c693e3c623e3c693ed098d181d0bfd0bed0bbd18cd0b7d183d0b9d182d0b520d0b8d0bdd182d0b5d180d184d0b5d0b9d181d18b20d0bad0bed0bbd0bbd0b5d0bad186d0b8d0b920d0b2d0bcd0b5d181d182d0be20d0bad0bbd0b0d181d181d0bed0b23c2f693e3c2f623e3c2f6c693e3c2f6f6c633e3c6f6c633e3c6c693e3c623e3c693ed095d181d0bbd0b820d0bdd0b520d0b7d0bdd0b0d0b5d182d0b52c20d187d182d0be20d0b8d181d0bfd0bed0bbd18cd0b7d0bed0b2d0b0d182d18c2c20d0b8d181d0bfd0bed0bbd18cd0b7d183d0b9d182d0b52061727261796c6973742c20686173686d61702c20686173687365743c2f693e3c2f623e3c2f6c693e3c2f6f6c633e3c6f6c633e3c6c693e3c623e3c693ed095d181d0bbd0b820d0b8d181d0bfd0bed0bbd18cd0b7d183d0b5d182d0b520d0b220d0bad0b0d187d0b5d181d182d0b2d0b520d0bad0bbd18ed187d0b5d0b920d181d0bed0b1d181d182d0b2d0b5d0bdd0bdd18bd0b520d0bad0bbd0b0d181d181d18b20d0bed0b1d18fd0b7d0b0d182d0b5d0bbd18cd0bdd0be20d0bfd180d0b0d0b2d0b8d0bbd18cd0bdd0bed0bb20d0bfd0b5d180d0b5d0bed0bfd180d0b5d0b4d0b5d0bbd0b8d182d0b520d18320d0bdd0b8d18520d0bcd0b5d182d0bed0b4d18b20657175616c73286f626a656374206f2920d0b82068617368636f646528293c2f693e3c2f623e3c2f6c693e3c2f6f6c633e3c6f6c633e3c6c693e3c623e3c693ed098d181d0bfd0bed0bbd18cd0b7d0bed0b2d0b0d0bdd0b8d0b520d0bcd0b0d181d181d0b8d0b2d0bed0b220d0b8d0bdd0bed0b3d0b4d0b020d0bcd0bed0b6d0b5d18220d0b4d0b0d182d18c20d0b2d18bd0b8d0b3d180d18bd18820d0b220d181d0bad0bed180d0bed181d182d0b82e3c2f693e3c2f623e3c2f6c693e3c2f6f6c633e"><ul><li><strong><em>Используйте интерфейсы коллекций вместо классов</em></strong></li></ul><ul><li><strong><em>Если не знаете, что использовать, используйте <a class="wiki_link" href="/wiki/show/vsm2_1step/ArrayList" title="ArrayList">ArrayList</a>, <a class="wiki_link" href="/wiki/show/vsm2_1step/HashMap" title="HashMap">HashMap</a>, <a class="wiki_link" href="/wiki/show/vsm2_1step/HashSet" title="HashSet">HashSet</a></em></strong></li></ul><ul><li><strong><em>Если используете в качестве ключей собственные классы обязательно правильнол переопределите у них методы equals(Object o) и hashCode()</em></strong></li></ul><ul><li><strong><em>Использование массивов иногда может дать выигрыш в скорости.</em></strong></li></ul></h4></div></div><div><br></div><div><br></div><div><br></div></body></html>