<html><head></head><body><p><span style="font-size:xx-large;">Нагрузочное тестирование</span><br>Для нагрузочного тестирования в системе используются тесты написанные при помощи apache-jmeter<br>Файлы тестов сохраняются в формате .jmx<br>Для того, чтобы понять, что такое JMeter рекомендую https://habrahabr.ru/post/140310/<br><br><strong><span style="font-size:large;"><em>Нагрузочные тесты OrderTable </em></span></strong></p><p>Используют новый ViewData API.<br>ip-saas\test\stress\OrderTable.jmx<br><span style="font-size:large;"></span></p><p><span style="font-size:large;">Описание теста (от заказчика)</span><br><em></em><br>Для тестирования использовался внешний генератор нагрузки jmeter. Коммуникация с сервером выполнялась посредством вызова универсального REST API. Для получения тренда при росте нагрузки сценарий воспроизводился 4 раза для 50, 100, 200 и 400 пользователей. <br>Сценарий тестирования <br>Пользователи входят в систему поочередно, в течение определенного промежутка времени (указано в результатах тестирования). Каждый пользователь выполняет следующую последовательность действий: <br>1.<span style="white-space:pre;">	</span>Аутентификация <br>2.<span style="white-space:pre;">	</span>Пауза N секунд <br>3.<span style="white-space:pre;">	</span>Создание заказа (Order) c пятью позициями заказа (OrderLine) <br>4.<span style="white-space:pre;">	</span>Пауза N секунд <br>5.<span style="white-space:pre;">	</span>Получение 100 экземпляров сущности Order с загруженным списком позиций заказа (OrderLine) и ссылкой на покупателя (Customer) <br>6.<span style="white-space:pre;">	</span>Переход к п. 2 (после совершения M переходов тест завершается). M в данном случае зависит от количества одновременно работающих в системе пользователей и является числом, достаточным для того, чтобы все заявленные пользователи одновременно работали в системе значительный промежуток времени. <br>Значения N и M приведены в разделе “результаты тестирования”. <br><br><em><span style="font-size:large;"><strong>Описание тестового сценария</strong></span></em></p><p><em></em><br>Параметры сценария - список переменных, изменяемых в сценарии<br>    numOfUsers - Число одновременных пользователей<br>    numOfOrdersForUser - Количество циклов запись-чтение для каждого пользователя<br>    rampUpPeriod - Время входа всех пользователей в систему<br>    orderListPageSize - Число запрашиваемых в списке заказов<br>    orderListRowsSkip - Отступ запрашиваемых в списке заказов<br>Параметры запросов по умолчанию - IP и port сервера<br>Основная ветка - Поскольку является блоком Thread Groupб указанное в нем выполняется для каждого из потоков. Обратите внимание на синтаксис обращения к параметрам: ${numOfUsers}<br>    Number of Threads Users - Число одновременных пользователей<br>    Ramp-Up Period - Время входа всех пользователей в систему<br>    Переменные сценария - список переменных и констант сценария <br>        maxPositions - число позиций в заказе        <br>        test_user_id,<br>        test_user_login,<br>        test_user_password,<br>        test_workspace_id,<br>        authToken - поля пользователя<br>        order_list_details_view_id,<br>        order_table_details_view_id - название Detail Display Settings у заказов и позиций<br>        PairSeparator, CreateButton, UpdateButton - служебные константы<br>        currentTimer - Продолжительность текущего простоя в мсек<br>    Заголовки запросов по-умолчанию - собственно то чем названо, можно обратить внимание на заголовок X-AUTH, в который передается переменная с токеном (до логина значение будет пустым)<br><br>    Создание заказов и товаров<br>        GetAuthToken - POST запрос на логин, <br>            имеет дополнительный заголовок Content-Type<br>            имеет препроцессор (код который выполняется до запроса), в котором устанавливается login пользователя из идентификатора потока<br>            имеет постпроцессор (код который выполняется после запроса), в котором сохраняет авторизационный токен<br>        Циклично создаем заказы - цикл исполняющий дочерние блоки numOfOrdersForUser раз<br>            CreateOrder - Transaction Controller (вместе с дочерними блоками будет показываться как один запрос с суммарным временем )<br>                post CREATE /json/view/order_table/process/create - POST запрос на создание Order<br>                    имеет дополнительный заголовок Content-Type<br>                    имеет препроцессор, в котором устанавливаются значения полей заказа в переменные для передачи в тело запроса<br>                    имеет постпроцессор (код который выполняется после запроса), в котором сохраняется id и время создания заказа<br>                    имеет таймер для ожидание 2-5 секунд, ВАЖНО, таймеры в JMeter нужно ставить не после блока, а внутри, это просто такой синтаксис, я в свое время часа два на это потерял<br>                Вносим в заказ maxPositions позиций - цикл на maxPositions=5 итераций<br>                    post CREATE /json/view/order_list/process/create - создание позиции в имеющемся заказе<br>                        имеет дополнительный заголовок Content-Type<br>                        имеет препроцессор, в котором устанавливаются значения полей позиции заказа в переменные для передачи в тело запроса<br>                GetOrdersList - GET запрос на список первых orderListPageSize заказов<br>                    имеет таймер для ожидание 2-5 секунд<br><br>    Отдельно стоящие отчеты    <br>        View Results Tree - просмотр всех запросов вместе с телом, используется при отладке, при числе потоков/пользователей больше 20 начинает сильно тормозить<br>        Aggregate Report - агрегированный отчет по времени запросов, используется при любом числе пользователей<br>        View Results in Table - просмотр заголовков отчетов, может использоваться при числе до пользователей 200-400<br>    Для очистки отчета от уже имеющихся данных перед каждым следующим запуском нажимаем кнопку Clear или Clrear All на панели (шестеренка с венеком и двумя венками соответственно)</p></body></html>