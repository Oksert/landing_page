<p><span style="font-size:xx-large;">Нагрузочное тестирование</span><br />Для нагрузочного тестирования в системе используются тесты написанные при помощи apache-jmeter<br />Файлы тестов сохраняются в формате .jmx<br />Для того, чтобы понять, что такое JMeter рекомендую https://habrahabr.ru/post/140310/<br /><br /><strong><span style="font-size:large;"><em>Нагрузочные тесты OrderTable </em></span></strong></p><p>Используют новый ViewData API.<br />ip-saas\test\stress\OrderTable.jmx<br /><span style="font-size:large;"></span></p><p><span style="font-size:large;">Описание теста (от заказчика)</span><br /><em></em><br />Для тестирования использовался внешний генератор нагрузки jmeter. Коммуникация с сервером выполнялась посредством вызова универсального REST API. Для получения тренда при росте нагрузки сценарий воспроизводился 4 раза для 50, 100, 200 и 400 пользователей.&nbsp;<br />Сценарий тестирования&nbsp;<br />Пользователи входят в систему поочередно, в течение определенного промежутка времени (указано в результатах тестирования). Каждый пользователь выполняет следующую последовательность действий:&nbsp;<br />1.<span style="white-space:pre;">	</span>Аутентификация&nbsp;<br />2.<span style="white-space:pre;">	</span>Пауза N секунд&nbsp;<br />3.<span style="white-space:pre;">	</span>Создание заказа (Order) c пятью позициями заказа (OrderLine)&nbsp;<br />4.<span style="white-space:pre;">	</span>Пауза N секунд&nbsp;<br />5.<span style="white-space:pre;">	</span>Получение 100 экземпляров сущности Order с загруженным списком позиций заказа (OrderLine) и ссылкой на покупателя (Customer)&nbsp;<br />6.<span style="white-space:pre;">	</span>Переход к п. 2 (после совершения M переходов тест завершается). M в данном случае зависит от количества одновременно работающих в системе пользователей и является числом, достаточным для того, чтобы все заявленные пользователи одновременно работали в системе значительный промежуток времени.&nbsp;<br />Значения N и M приведены в разделе &ldquo;результаты тестирования&rdquo;.&nbsp;<br /><br /><em><span style="font-size:large;"><strong>Описание тестового сценария</strong></span></em></p><p><em></em><br />Параметры сценария - список переменных, изменяемых в сценарии<br />&nbsp; &nbsp; numOfUsers - Число одновременных пользователей<br />&nbsp; &nbsp; numOfOrdersForUser - Количество циклов запись-чтение для каждого пользователя<br />&nbsp; &nbsp; rampUpPeriod - Время входа всех пользователей в систему<br />&nbsp; &nbsp; orderListPageSize - Число запрашиваемых в списке заказов<br />&nbsp; &nbsp; orderListRowsSkip - Отступ запрашиваемых в списке заказов<br />Параметры запросов по умолчанию - IP и port сервера<br />Основная ветка - Поскольку является блоком Thread Groupб указанное в нем выполняется для каждого из потоков. Обратите внимание на синтаксис обращения к параметрам: ${numOfUsers}<br />&nbsp; &nbsp; Number of Threads Users - Число одновременных пользователей<br />&nbsp; &nbsp; Ramp-Up Period - Время входа всех пользователей в систему<br />&nbsp; &nbsp; Переменные сценария - список переменных и констант сценария&nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; maxPositions - число позиций в заказе &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; test_user_id,<br />&nbsp; &nbsp; &nbsp; &nbsp; test_user_login,<br />&nbsp; &nbsp; &nbsp; &nbsp; test_user_password,<br />&nbsp; &nbsp; &nbsp; &nbsp; test_workspace_id,<br />&nbsp; &nbsp; &nbsp; &nbsp; authToken - поля пользователя<br />&nbsp; &nbsp; &nbsp; &nbsp; order_list_details_view_id,<br />&nbsp; &nbsp; &nbsp; &nbsp; order_table_details_view_id - название Detail Display Settings у заказов и позиций<br />&nbsp; &nbsp; &nbsp; &nbsp; PairSeparator, CreateButton, UpdateButton - служебные константы<br />&nbsp; &nbsp; &nbsp; &nbsp; currentTimer - Продолжительность текущего простоя в мсек<br />&nbsp; &nbsp; Заголовки запросов по-умолчанию - собственно то чем названо, можно обратить внимание на заголовок X-AUTH, в который передается переменная с токеном (до логина значение будет пустым)<br /><br />&nbsp; &nbsp; Создание заказов и товаров<br />&nbsp; &nbsp; &nbsp; &nbsp; GetAuthToken - POST запрос на логин,&nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет дополнительный заголовок Content-Type<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет препроцессор (код который выполняется до запроса), в котором устанавливается login пользователя из идентификатора потока<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет постпроцессор (код который выполняется после запроса), в котором сохраняет авторизационный токен<br />&nbsp; &nbsp; &nbsp; &nbsp; Циклично создаем заказы - цикл исполняющий дочерние блоки numOfOrdersForUser раз<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateOrder - Transaction Controller (вместе с дочерними блоками будет показываться как один запрос с суммарным временем )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; post CREATE /json/view/order_table/process/create - POST запрос на создание Order<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет дополнительный заголовок Content-Type<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет препроцессор, в котором устанавливаются значения полей заказа в переменные для передачи в тело запроса<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет постпроцессор (код который выполняется после запроса), в котором сохраняется id и время создания заказа<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет таймер для ожидание 2-5 секунд, ВАЖНО, таймеры в JMeter нужно ставить не после блока, а внутри, это просто такой синтаксис, я в свое время часа два на это потерял<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Вносим в заказ maxPositions позиций - цикл на maxPositions=5 итераций<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; post CREATE /json/view/order_list/process/create - создание позиции в имеющемся заказе<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет дополнительный заголовок Content-Type<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет препроцессор, в котором устанавливаются значения полей позиции заказа в переменные для передачи в тело запроса<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetOrdersList - GET запрос на список первых orderListPageSize заказов<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; имеет таймер для ожидание 2-5 секунд<br /><br />&nbsp; &nbsp; Отдельно стоящие отчеты &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; View Results Tree - просмотр всех запросов вместе с телом, используется при отладке, при числе потоков/пользователей больше 20 начинает сильно тормозить<br />&nbsp; &nbsp; &nbsp; &nbsp; Aggregate Report - агрегированный отчет по времени запросов, используется при любом числе пользователей<br />&nbsp; &nbsp; &nbsp; &nbsp; View Results in Table - просмотр заголовков отчетов, может использоваться при числе до пользователей 200-400<br />&nbsp; &nbsp; Для очистки отчета от уже имеющихся данных перед каждым следующим запуском нажимаем кнопку Clear или Clrear All на панели (шестеренка с венеком и двумя венками соответственно)</p>